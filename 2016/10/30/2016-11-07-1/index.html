<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://zksyp.me">
  <title>View的绘制流程探索 | Zksyp的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="从setContentView说起如题，探索View的绘制流程，我们从大家最容易想到的方法setContentView()入手。setContentView(int layoutResID)方法是把我们在xml文件里画好的布局呈现在窗口中的纽带。进到该方法内，提示链接到Activity 的setContentView方法，最后我们可以看到：
1234public void setContentVi">
<meta property="og:type" content="article">
<meta property="og:title" content="View的绘制流程探索">
<meta property="og:url" content="http://zksyp.me/2016/10/30/2016-11-07-1/index.html">
<meta property="og:site_name" content="Zksyp的博客">
<meta property="og:description" content="从setContentView说起如题，探索View的绘制流程，我们从大家最容易想到的方法setContentView()入手。setContentView(int layoutResID)方法是把我们在xml文件里画好的布局呈现在窗口中的纽带。进到该方法内，提示链接到Activity 的setContentView方法，最后我们可以看到：
1234public void setContentVi">
<meta property="og:image" content="http://og407vfi8.bkt.clouddn.com/14785059352930.jpg">
<meta property="og:image" content="http://og407vfi8.bkt.clouddn.com/14785095066417.jpg">
<meta property="og:image" content="http://og407vfi8.bkt.clouddn.com/14791232890128.jpg">
<meta property="og:image" content="http://og407vfi8.bkt.clouddn.com/14803500905009.jpg">
<meta property="og:image" content="http://og407vfi8.bkt.clouddn.com/14802635537295.jpg">
<meta property="og:updated_time" content="2016-12-15T01:39:55.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="View的绘制流程探索">
<meta name="twitter:description" content="从setContentView说起如题，探索View的绘制流程，我们从大家最容易想到的方法setContentView()入手。setContentView(int layoutResID)方法是把我们在xml文件里画好的布局呈现在窗口中的纽带。进到该方法内，提示链接到Activity 的setContentView方法，最后我们可以看到：
1234public void setContentVi">
<meta name="twitter:image" content="http://og407vfi8.bkt.clouddn.com/14785059352930.jpg">
  
    <link rel="alternative" href="/atom.xml" title="Zksyp的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/img/favicon.ico">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/assets/blogImg/zksyp.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Zksyp</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/photos">相册</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/zksyp" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="/" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Zksyp</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/assets/blogImg/zksyp.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Zksyp</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/photos">相册</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/zksyp" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-2016-11-07-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      View的绘制流程探索
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="从setContentView说起"><a href="#从setContentView说起" class="headerlink" title="从setContentView说起"></a>从setContentView说起</h2><p>如题，探索View的绘制流程，我们从大家最容易想到的方法setContentView()入手。setContentView(int layoutResID)方法是把我们在xml文件里画好的布局呈现在窗口中的纽带。进到该方法内，提示链接到Activity 的setContentView方法，最后我们可以看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</div><div class="line">        getWindow().setContentView(layoutResID);</div><div class="line">        initWindowDecorActionBar();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>它调用的是抽象类window的setContentView方法，仔细追溯，我们发现<br><img src="http://og407vfi8.bkt.clouddn.com/14785059352930.jpg" alt=""></p>
<p>实际调用的是phoneWindow类，也就是window类的一个实现类的setContentView方法，进到该方法：<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</div><div class="line">        <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></div><div class="line">        <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></div><div class="line">        <span class="comment">// before this happens.</span></div><div class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</div><div class="line">            installDecor();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">            mContentParent.removeAllViews();</div><div class="line">        &#125;</div><div class="line"><span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">            <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</div><div class="line">                    getContext());</div><div class="line">            transitionTo(newScene);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mLayoutInflater.inflate(layoutResID, mContentParent);</div><div class="line">        &#125;</div><div class="line">        mContentParent.requestApplyInsets();</div><div class="line">        <span class="keyword">final</span> Callback cb = getCallback();</div><div class="line">        <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</div><div class="line">            cb.onContentChanged();</div><div class="line">        &#125;</div><div class="line">        mContentParentExplicitlySet = <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当mContentParent为空，也就是内容的父View为空时，调用installDecor()方法，进到该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</div><div class="line">            mDecor = generateDecor(-<span class="number">1</span>);<span class="comment">//生成一个DecorView</span></div><div class="line">            <span class="comment">//...</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mDecor.setWindow(<span class="keyword">this</span>);<span class="comment">//绑定Window</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</div><div class="line">            mContentParent = generateLayout(mDecor);<span class="comment">//生成ContentView</span></div><div class="line">            <span class="comment">//设置标题之类的、或者一些图标之类的</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以发现出现了一个新的类，DecorView，该类继承自FrameLayout，该类是window的第一层View，代码中可以的看到，首先生成了一个decorView，然后把该View作为参数，调用generateLayout()方法，生成了我们需要的父View——mContentParent，该方法中的其他代码主要是用来设置window的主题配置UI属性等等，点进关键的方法generateDecor()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;  </div><div class="line">    <span class="comment">// Apply data from current theme.  </span></div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="comment">//1 根据requestFeature()和Activity节点的android:theme="" 设置好 features值  </span></div><div class="line">    <span class="comment">//2 根据设定好的 features值，即特定风格属性，选择不同的窗口修饰布局文件  </span></div><div class="line">    <span class="keyword">int</span> layoutResource;  <span class="comment">//窗口修饰布局文件    </span></div><div class="line">    <span class="keyword">int</span> features = getLocalFeatures();  </div><div class="line">    <span class="comment">// System.out.println("Features: 0x" + Integer.toHexString(features));  </span></div><div class="line">    <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_LEFT_ICON) | (<span class="number">1</span> &lt;&lt; FEATURE_RIGHT_ICON))) != <span class="number">0</span>) &#123;  </div><div class="line">        <span class="keyword">if</span> (mIsFloating) &#123;  </div><div class="line">            layoutResource = com.android.internal.R.layout.dialog_title_icons;  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            layoutResource = com.android.internal.R.layout.screen_title_icons;  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// System.out.println("Title Icons!");  </span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_PROGRESS) | (<span class="number">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != <span class="number">0</span>) &#123;  </div><div class="line">        <span class="comment">// Special case for a window with only a progress bar (and title).  </span></div><div class="line">        <span class="comment">// XXX Need to have a no-title version of embedded windows.  </span></div><div class="line">        layoutResource = com.android.internal.R.layout.screen_progress;  </div><div class="line">        <span class="comment">// System.out.println("Progress!");  </span></div><div class="line">    &#125;   </div><div class="line">    <span class="comment">//...  </span></div><div class="line">    <span class="comment">//3 选定了窗口修饰布局文件 ，添加至DecorView对象里，并且指定mcontentParent值  </span></div><div class="line">    mDecor.startChanging();</div><div class="line">    mDecor.onResourcesLoaded(mLayoutInflater,layoutResource);</div><div class="line">  </div><div class="line">ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);  </div><div class="line">    <span class="keyword">if</span> (contentParent == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Window couldn't find content container view"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != <span class="number">0</span>) &#123;  </div><div class="line">        ProgressBar progress = getCircularProgressBar(<span class="keyword">false</span>);  </div><div class="line">        <span class="keyword">if</span> (progress != <span class="keyword">null</span>) &#123;  </div><div class="line">            progress.setIndeterminate(<span class="keyword">true</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//...  </span></div><div class="line">    <span class="keyword">return</span> contentParent;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如代码旁的注释，先获取窗口的布局修饰资源文件，再按照里面的参数，调用 mDecor.onResourcesLoaded(mLayoutInflater, layoutResource)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">onResourcesLoaded</span><span class="params">(LayoutInflater inflater, <span class="keyword">int</span> layoutResource)</span> </span>&#123;</div><div class="line">       <span class="comment">//...</span></div><div class="line">       mDecorCaptionView = createDecorCaptionView(inflater);</div><div class="line">       <span class="keyword">final</span> View root = inflater.inflate(layoutResource, <span class="keyword">null</span>);</div><div class="line">       <span class="keyword">if</span> (mDecorCaptionView != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">if</span> (mDecorCaptionView.getParent() == <span class="keyword">null</span>) &#123;</div><div class="line">               addView(mDecorCaptionView,</div><div class="line">                       <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</div><div class="line">           &#125;</div><div class="line">           mDecorCaptionView.addView(root,</div><div class="line">                   <span class="keyword">new</span> ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">// Put it below the color views.</span></div><div class="line">           addView(root, <span class="number">0</span>, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</div><div class="line">       &#125;</div><div class="line">       mContentRoot = (ViewGroup) root;</div><div class="line">       initializeElevation();</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>将mDecorView作为根视图将对应的该窗口的布局视图添加进去，之后获取ID为content的View，并将其赋值给ContentParent，最后我们就得到了mDecor和ContentParent对象，回到phoneWindow的setContentView方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</div><div class="line">        <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></div><div class="line">        <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></div><div class="line">        <span class="comment">// before this happens.</span></div><div class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</div><div class="line">            installDecor();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">            mContentParent.removeAllViews();</div><div class="line">        &#125;</div><div class="line"><span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">            <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</div><div class="line">                    getContext());</div><div class="line">            transitionTo(newScene);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mLayoutInflater.inflate(layoutResID, mContentParent);</div><div class="line">        &#125;</div><div class="line">        mContentParent.requestApplyInsets();</div><div class="line">        <span class="keyword">final</span> Callback cb = getCallback();</div><div class="line">        <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</div><div class="line">            cb.onContentChanged();</div><div class="line">        &#125;</div><div class="line">        mContentParentExplicitlySet = <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过inflate方法把对应的布局加载到窗口中。</p>
<p>以上的过程概括一下，就是先创建一个DecorView对象，将其作为根视图将对应的窗口修饰布局文件加载进去，然后取其中id为content的frameLayout指定为父View，最后把我们自定义在xml中的布局放到这个framelyout中，这样，我们就完成把xml布局绑定到窗口的过程。结构概图如下：</p>
<p><img src="http://og407vfi8.bkt.clouddn.com/14785095066417.jpg" alt=""></p>
<h2 id="根View生成后，来说说View的绘制"><a href="#根View生成后，来说说View的绘制" class="headerlink" title="根View生成后，来说说View的绘制"></a>根View生成后，来说说View的绘制</h2><p>获取到根View之后，我们把我们自己添加的View通过addView()方法添加进去，方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index, LayoutParams params)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (DBG) &#123;</div><div class="line">           System.out.println(<span class="keyword">this</span> + <span class="string">" addView"</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add a null child view to a ViewGroup"</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// addViewInner() will call child.requestLayout() when setting the new LayoutParams</span></div><div class="line">       <span class="comment">// therefore, we call requestLayout() on ourselves before, so that the child's request</span></div><div class="line">       <span class="comment">// will be blocked at our level</span></div><div class="line">       requestLayout();</div><div class="line">       invalidate(<span class="keyword">true</span>);</div><div class="line">       addViewInner(child, index, params, <span class="keyword">false</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>里面关键的方法就是requestLayout()方法，进到该方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Call this when something has changed which has invalidated the</div><div class="line">    * layout of this view. This will schedule a layout pass of the view</div><div class="line">    * tree. This should not be called while the view hierarchy is currently in a layout</div><div class="line">    * pass (&#123;<span class="doctag">@link</span> #isInLayout()&#125;. If layout is happening, the request may be honored at the</div><div class="line">    * end of the current layout pass (and then layout will run again) or after the current</div><div class="line">    * frame is drawn and the next layout occurs.</div><div class="line">    *</div><div class="line">    * &lt;p&gt;Subclasses which override this method should call the superclass method to</div><div class="line">    * handle possible request-during-layout errors correctly.&lt;/p&gt;</div><div class="line">    */</div><div class="line">   <span class="meta">@CallSuper</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (mMeasureCache != <span class="keyword">null</span>) mMeasureCache.clear();</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="comment">// Only trigger request-during-layout logic if this is the view requesting it,</span></div><div class="line">           <span class="comment">// not the views in its parent hierarchy</span></div><div class="line">           ViewRootImpl viewRoot = getViewRootImpl();</div><div class="line">           <span class="keyword">if</span> (viewRoot != <span class="keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;</div><div class="line">               <span class="keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="keyword">this</span>)) &#123;</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           mAttachInfo.mViewRequestingLayout = <span class="keyword">this</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       mPrivateFlags |= PFLAG_FORCE_LAYOUT;</div><div class="line">       mPrivateFlags |= PFLAG_INVALIDATED;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (mParent != <span class="keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</div><div class="line">           mParent.requestLayout();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">this</span>) &#123;</div><div class="line">           mAttachInfo.mViewRequestingLayout = <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看到会获取一个ViewRootImpl类的对象，之后会触发ViewRootImpl类中的performTraversals()这一异步的方法，进到该方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// cache mView since it is used so much below...</span></div><div class="line">        <span class="keyword">final</span> View host = mView;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (host == <span class="keyword">null</span> || !mAdded)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="comment">//是否正在遍历</span></div><div class="line">        mIsInTraversal = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">//是否马上绘制View</span></div><div class="line">        mWillDrawSoon = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        .............</div><div class="line">        <span class="comment">//顶层视图DecorView所需要窗口的宽度和高度</span></div><div class="line">        <span class="keyword">int</span> desiredWindowWidth;</div><div class="line">        <span class="keyword">int</span> desiredWindowHeight;</div><div class="line"></div><div class="line">        .....................</div><div class="line">        <span class="comment">//在构造方法中mFirst已经设置为true，表示是否是第一次绘制DecorView</span></div><div class="line">        <span class="keyword">if</span> (mFirst) &#123;</div><div class="line">            mFullRedrawNeeded = <span class="keyword">true</span>;</div><div class="line">            mLayoutRequested = <span class="keyword">true</span>;</div><div class="line">            <span class="comment">//如果窗口的类型是有状态栏的，那么顶层视图DecorView所需要窗口的宽度和高度就是除了状态栏</span></div><div class="line">            <span class="keyword">if</span> (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL</div><div class="line">                    || lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) &#123;</div><div class="line">                <span class="comment">// NOTE -- system code, won't try to do compat mode.</span></div><div class="line">                Point size = <span class="keyword">new</span> Point();</div><div class="line">                mDisplay.getRealSize(size);</div><div class="line">                desiredWindowWidth = size.x;</div><div class="line">                desiredWindowHeight = size.y;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则顶层视图DecorView所需要窗口的宽度和高度就是整个屏幕的宽高</span></div><div class="line">                DisplayMetrics packageMetrics =</div><div class="line">                    mView.getContext().getResources().getDisplayMetrics();</div><div class="line">                desiredWindowWidth = packageMetrics.widthPixels;</div><div class="line">                desiredWindowHeight = packageMetrics.heightPixels;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">............</div><div class="line"></div><div class="line"> <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</div><div class="line"> <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div><div class="line"></div><div class="line">  <span class="comment">// Ask host how big it wants to be</span></div><div class="line">  <span class="comment">//执行测量操作</span></div><div class="line">performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);</div><div class="line"></div><div class="line">........................</div><div class="line"><span class="comment">//执行布局操作</span></div><div class="line"> performLayout(lp, desiredWindowWidth, desiredWindowHeight);</div><div class="line"></div><div class="line">.......................</div><div class="line"><span class="comment">//执行绘制操作</span></div><div class="line">performDraw();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>省略掉部分代码，展示了些关键代码后，可以看到，经过performMeasure(),performLayout(),和performDraw()三个方法，也即对应着，measure，layout，draw三个过程，才最终将一个View绘制出来。其中measure用来测量View的宽和高，layout用来确定View在父容器中的放置位置，而draw用来将View绘制在屏幕上。<br>主要流程参考下图(截图来源安卓内核剖析)：</p>
<p><img src="http://og407vfi8.bkt.clouddn.com/14791232890128.jpg" alt=""></p>
<h2 id="主要过程解析"><a href="#主要过程解析" class="headerlink" title="主要过程解析"></a>主要过程解析</h2><h3 id="Measure过程"><a href="#Measure过程" class="headerlink" title="Measure过程"></a>Measure过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Ask host how big it wants to be </span></div><div class="line">performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);</div></pre></td></tr></table></figure>
<p>调用此方法是根据窗口大小获取子视图大小的测量标准，其中宽度标准和高度标准分别保存到childWidthMeasureSpec和childHeightMeasureSpec变量中。<br>measureSpec参数是View测量的一个关键的参数，父容器会影响View的MeasureSpec的创建，MeasureSpec不是有LayoutParams唯一决定的，LayoutParams需要和父容器一起才能决定View的measureSpec，从而进一步决定View的宽和高，在 View 测量过程中，系统会将该 View 的 LayoutParams 参数在父容器的约束下转换成对应的 MeasureSpec ，然后再根据这个 measureSpec 来测量 View 的宽高。</p>
<p>measureSpec是一个32位的int值，改变量的高16位代表类型，低16位代表实际的大小。measureSpec是SpecMode和SpecSize打包而成的一个int值，而specMode有三类，如下：</p>
<ol>
<li>UNSPECIFIED 父容器不对 View 有任何的限制，要多大给多大，这种情况下   一般用于系统内部，表示一种测量的状态。</li>
<li>EXACTLY 父容器已经检测出 View 所需要的精确大小，这个时候 View 的最终大小就是 SpecSize 所指定的值，它对应于LayoutParams 中的 match_parent 和具体的数值这两种模式</li>
<li><p>AT_MOST 父容器指定了一个可用大小即 SpecSize，View 的大小不能大于这个值，具体是什么值要看不同 View 的具体实现。它对应于 LayoutParams 中的 wrap_content。</p>
<p>而变量的获取方法如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获得view宽高的测量规格，mWidth和mHeight表示窗口在屏幕当中的的宽高，默认是屏幕大小，当窗口大小变化时，它的大小也会相应发生变化，比如说，当前窗口中有键盘时，它的大小就是屏幕大小减去键盘所占的大小。</span></div><div class="line"><span class="comment">//lp.widthhe和lp.height表示DecorView根布局宽和高</span></div><div class="line">childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth,lp.width);</div><div class="line">childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div></pre></td></tr></table></figure>
<p>进入到getRootMeasureSpec()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> measureSpec;</div><div class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">        <span class="comment">// Window can't resize. Force root view to be windowSize.</span></div><div class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line">        <span class="comment">// Window can resize. Set max size for root view.</span></div><div class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></div><div class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> measureSpec;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到它其实是转到MeasureSpec的makeMeasureSpec方法，而上面说到的spec的32位的值就是从这里得来的。makeMeasureSpec方法就是将SpecSize和SpecMode包装成32位的int值。包装的过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(@IntRange(from = <span class="number">0</span>, to = (<span class="number">1</span> &lt;&lt; MeasureSpec.MODE_SHIFT)</span> - 1) <span class="keyword">int</span> size,</span></div><div class="line">                                  @MeasureSpecMode <span class="keyword">int</span> mode) &#123;</div><div class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">        <span class="keyword">return</span> size + mode;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">当重要的测量参数了解之后，我们看看具体的measure()过程。</div><div class="line">performMeasure()方法如下：</div><div class="line"></div><div class="line">```<span class="function">java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> &#123;</div><div class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到它转到了View的measure()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">if</span> (forceLayout || needsLayout) &#123;</div><div class="line">        <span class="comment">// first clears the measured dimension flag</span></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</div><div class="line"></div><div class="line">        resolveRtlPropertiesIfNeeded();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> cacheIndex = forceLayout ? -<span class="number">1</span> : mMeasureCache.indexOfKey(key);</div><div class="line">        <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</div><div class="line">            <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></div><div class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125; </div><div class="line"></div><div class="line">        <span class="comment">//...</span></div><div class="line"></div><div class="line">    mOldWidthMeasureSpec = widthMeasureSpec;</div><div class="line">    mOldHeightMeasureSpec = heightMeasureSpec;</div><div class="line"></div><div class="line">    mMeasureCache.put(key, ((<span class="keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</div><div class="line">            (<span class="keyword">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调进onMeasure()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">调用了setMeasuredDimension将测量的宽高设置进去,getDefaultSize方法用于获取测量宽高。具体实现如下：</div><div class="line"></div><div class="line">```<span class="function">java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> &#123;</div><div class="line">    <span class="keyword">int</span> result = size;</div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        result = size;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        result = specSize;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要就是从measureSpec中取出specMode和specSize，然后就是AT_MOST和EXACTLY的情况下，都返回specSize，这个specSize就是测量的值了。<br>这个就是整个View的测量过程。<br>而ViewGroup的测量过程，就是自身的测量加上对子View的测量，在ViewGroup中定义了一个measureChildren方法去遍历子元素，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">     <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">     <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">         <span class="keyword">final</span> View child = children[i];</div><div class="line">         <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是用一个for循环去遍历子View，然后转到measureChild()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">        <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">            mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">            mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终也就是调用子View的measure()方法。以上就是ViewGroup的measure过程，当measure过程完成后，就可以调用getMeasuredWidth/getMeasuredHeight方法来获取测量宽高了。</p>
<h3 id="onLayout过程"><a href="#onLayout过程" class="headerlink" title="onLayout过程"></a>onLayout过程</h3><p>当执行完measure操作后，接下来的layout操作是相对简单的，其目的就是父视图按照子视图的大小及布局参数，将子视图放到合适的位置上，布局参数最核心的就是处理gravity参数。其执行过程大致如图：</p>
<p><img src="http://og407vfi8.bkt.clouddn.com/14803500905009.jpg" alt=""></p>
<p>View中layout()函数的原型为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="comment">//这些参数指定了该子视图在父视图中左，上，下，右的位置</span></div><div class="line">        <span class="keyword">int</span> oldL = mLeft;</div><div class="line">        <span class="keyword">int</span> oldT = mTop;</div><div class="line">        <span class="keyword">int</span> oldB = mBottom;</div><div class="line">        <span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line"><span class="comment">//该方法是用来保存这些变量，但在保存之前会先比对这些参数是否和原来的相同</span></div><div class="line">        <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"><span class="comment">//然后回调onLayout()方法</span></div><div class="line">        <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">                <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                    listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>而回调的OnLayout()方法是子类根据需求自己去具体实现的。<br>我们看下framlayout的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调进layoutChildren()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="keyword">final</span> View child = getChildAt(i);</div><div class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</div><div class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> childLeft;</div><div class="line">            <span class="keyword">int</span> childTop;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> gravity = lp.gravity;</div><div class="line">            <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</div><div class="line">                gravity = DEFAULT_CHILD_GRAVITY;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</div><div class="line"></div><div class="line">            <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</div><div class="line">                <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</div><div class="line">                    childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</div><div class="line">                    lp.leftMargin - lp.rightMargin;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> Gravity.RIGHT:</div><div class="line">                    <span class="keyword">if</span> (!forceLeftGravity) &#123;</div><div class="line">                        childLeft = parentRight - width - lp.rightMargin;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                <span class="keyword">case</span> Gravity.LEFT:</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    childLeft = parentLeft + lp.leftMargin;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">switch</span> (verticalGravity) &#123;</div><div class="line">                <span class="keyword">case</span> Gravity.TOP:</div><div class="line">                    childTop = parentTop + lp.topMargin;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</div><div class="line">                    childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</div><div class="line">                    lp.topMargin - lp.bottomMargin;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> Gravity.BOTTOM:</div><div class="line">                    childTop = parentBottom - height - lp.bottomMargin;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    childTop = parentTop + lp.topMargin;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面就是根据我们上面所说的重要参数gravity和调用子View的layout方法去设置子View的位置。<br>以上就是layout的过程。</p>
<h3 id="onDraw过程"><a href="#onDraw过程" class="headerlink" title="onDraw过程"></a>onDraw过程</h3><p>在执行完测量和布局操作后，紧接着的就是绘制操作，该过程主要就是把View对象绘制到屏幕上，如果该View是一个ViewGroup，则需要递归绘制其所包含的虽有子View。绘制元素主要有以下四个：<br>1 View背景<br>2 View本身的内容<br>3 渐变的边框<br>4 滚动条，就像scrollView试图滚动时出现的滚动条，安卓中的滚动条仅仅是用来显示滚动的状态，并不能被用户直接下拉</p>
<p>而在操作过程中一般只需要重载View的onDraw()函数，来绘制View本身的内容，其他三个元素都是由View系统自动完成的，我们只需要通过相应的接口设置元素的具体颜色等参数。<br>类似于OnLayout()操作，绘制的总体过程如下图：<br><img src="http://og407vfi8.bkt.clouddn.com/14802635537295.jpg" alt=""></p>
<h2 id="View的滚动-scroll类的浅析"><a href="#View的滚动-scroll类的浅析" class="headerlink" title="View的滚动 scroll类的浅析"></a>View的滚动 scroll类的浅析</h2><p>View的滚动可以依靠自身的scroll方法，包括ScrollTo 和ScrollBy方法<br>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;  </div><div class="line">        <span class="keyword">int</span> oldX = mScrollX;  </div><div class="line">        <span class="keyword">int</span> oldY = mScrollY;  </div><div class="line">        mScrollX = x;  </div><div class="line">        mScrollY = y;  </div><div class="line">        invalidateParentCaches();  </div><div class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);  </div><div class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;  </div><div class="line">            postInvalidateOnAnimation();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </div><div class="line">    scrollTo(mScrollX + x, mScrollY + y);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>scrollBy方法实际就是调用scrollTo方法，scrollTo是滚动到具体坐标，srollBy是在前一次的基础上滚动。<br>主要原理就是进行一个invalidate操作，进而调用View的draw方法。也就是重绘界面的操作。<br>layout的scrollBy方法 滚动的是内部的子View。</p>
<p>Android里Scroller类是为了实现View平滑滚动的一个Helper类。实际上如果不通过Scroller类，只是通过scrollTo,scrollBy方法滚动，并不是平滑的滚动，而是瞬间的滚动。<br>主要涉及的方法是以下的一些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span> </span>&#123;  </div><div class="line">        mMode = SCROLL_MODE;  </div><div class="line">        mFinished = <span class="keyword">false</span>;  </div><div class="line">        mDuration = duration;  </div><div class="line">        mStartTime = AnimationUtils.currentAnimationTimeMillis();  </div><div class="line">        mStartX = startX;  </div><div class="line">        mStartY = startY;  </div><div class="line">        mFinalX = startX + dx;  </div><div class="line">        mFinalY = startY + dy;  </div><div class="line">        mDeltaX = dx;  </div><div class="line">        mDeltaY = dy;  </div><div class="line">        mDurationReciprocal = <span class="number">1.0f</span> / (<span class="keyword">float</span>) mDuration;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该方法就是对滚动的参数进行预先的设置。<br>startX,startY起始坐标，dx,dy滚动的偏移值，duration平滑滚动的时间。</p>
<p>而确定每时每刻滚动的位置，则调用的方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Call this when you want to know the new location.  If it returns true,</div><div class="line">     * the animation is not yet finished.</div><div class="line">     */ </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">computeScrollOffset</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mFinished) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> timePassed = (<span class="keyword">int</span>)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);</div><div class="line">    </div><div class="line">        <span class="keyword">if</span> (timePassed &lt; mDuration) &#123;</div><div class="line">            <span class="keyword">switch</span> (mMode) &#123;</div><div class="line">            <span class="keyword">case</span> SCROLL_MODE:</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</div><div class="line">                mCurrX = mStartX + Math.round(x * mDeltaX);</div><div class="line">                mCurrY = mStartY + Math.round(x * mDeltaY);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> FLING_MODE:</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> t = (<span class="keyword">float</span>) timePassed / mDuration;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = (<span class="keyword">int</span>) (NB_SAMPLES * t);</div><div class="line">                <span class="keyword">float</span> distanceCoef = <span class="number">1</span>.f;</div><div class="line">                <span class="keyword">float</span> velocityCoef = <span class="number">0</span>.f;</div><div class="line">                <span class="keyword">if</span> (index &lt; NB_SAMPLES) &#123;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> t_inf = (<span class="keyword">float</span>) index / NB_SAMPLES;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> t_sup = (<span class="keyword">float</span>) (index + <span class="number">1</span>) / NB_SAMPLES;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> d_inf = SPLINE_POSITION[index];</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> d_sup = SPLINE_POSITION[index + <span class="number">1</span>];</div><div class="line">                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);</div><div class="line">                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                mCurrVelocity = velocityCoef * mDistance / mDuration * <span class="number">1000.0f</span>;</div><div class="line">                </div><div class="line">                mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));</div><div class="line">                <span class="comment">// Pin to mMinX &lt;= mCurrX &lt;= mMaxX</span></div><div class="line">                mCurrX = Math.min(mCurrX, mMaxX);</div><div class="line">                mCurrX = Math.max(mCurrX, mMinX);</div><div class="line">                </div><div class="line">                mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));</div><div class="line">                <span class="comment">// Pin to mMinY &lt;= mCurrY &lt;= mMaxY</span></div><div class="line">                mCurrY = Math.min(mCurrY, mMaxY);</div><div class="line">                mCurrY = Math.max(mCurrY, mMinY);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) &#123;</div><div class="line">                    mFinished = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            mCurrX = mFinalX;</div><div class="line">            mCurrY = mFinalY;</div><div class="line">            mFinished = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>正如方法介绍的一样，该方法就是在需要确定位置时回调的。</p>
<p>方法中大致的意思就是：在startScroll()方法的时候获取了当前的动画毫秒赋值给了mStartTime，在computeScrollOffset()中再一次调用AnimationUtils.currentAnimationTimeMillis()来获取动画。毫秒减去mStartTime就是持续时间了，然后进去if判断，如果动画持续时间小于我们设置的滚动持续时间mDuration，进去switch的SCROLL_MODE(这个mode我们在start的时候赋了这个值)，然后根据Interpolator来计算出在该时间段里面移动的距离，赋值给mCurrX， mCurrY， 所以该方法的作用是，计算在0到mDuration时间段内滚动的偏移量，并且判断滚动是否结束，true代表还没结束，false则表示滚动结束了。</p>
<p>总的流程大致就是：调用Scroller的startScroll()方法进行滚动的参数的初始化设置，然后会使view进行重绘，调用View的invalidate()方法。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/30/2016-11-07-1/" class="archive-article-date">
  	<time datetime="2016-10-29T16:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-30</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android原理学习/">Android原理学习</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2016/11/25/2016-12-13/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          Java设计模式——观察者模式
        
      </div>
    </a>
  
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="2016-11-07-1" data-title="View的绘制流程探索" data-url="http://zksyp.me/2016/10/30/2016-11-07-1/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"zksyp-hexo"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Zksyp
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Android原理学习/" style="font-size: 10px;">Android原理学习</a> <a href="/tags/Android框架学习/" style="font-size: 10px;">Android框架学习</a> <a href="/tags/Java设计模式/" style="font-size: 20px;">Java设计模式</a> <a href="/tags/git代码管理/" style="font-size: 10px;">git代码管理</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">Zksyp,&lt;br&gt;一枚小小的码农。&lt;br/&gt;</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>